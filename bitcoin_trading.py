# -*- coding: utf-8 -*-
"""bitcoin_trading.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J6vRr9OwRhKn-eiTAUdttiIXDTSX0RtU

<a href="https://colab.research.google.com/github/JulioLaz/bitcoin_trading/blob/main/bitcoin_trading.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# BitCoint Trading

#Usaremos yf.download():

Es una función de la biblioteca yfinance de Python que permite descargar los precios históricos de una acción de Yahoo Finance en un DataFrame de Pandas. La función acepta varios parámetros, incluyendo el símbolo de la acción, el período de tiempo (por ejemplo, "1 año"), el intervalo de tiempo (por ejemplo, "1 día", "1 hora" o "5 minutos"), entre otros.

#  Indicadores técnicos utilizados en análisis: RSI y MACD,MACD Signal, tendencia, media móvil de 50 y 200 días.

RSI y MACD son dos indicadores técnicos utilizados en análisis técnico para evaluar la fuerza y dirección de la tendencia de un activo financiero.

RSI significa "Relative Strength Index" o "Índice de Fuerza Relativa", es un indicador que mide la fuerza de la tendencia del precio de un activo y determina si el activo está sobrecomprado o sobrevendido. El RSI se calcula utilizando una fórmula matemática que compara los días en que el precio subió con los días en que el precio bajó, y su resultado oscila entre 0 y 100.

MACD significa "Moving Average Convergence Divergence" o "Convergencia y Divergencia de Medias Móviles", es un indicador que mide la diferencia entre dos medias móviles exponenciales de diferentes períodos de tiempo. El MACD se utiliza para identificar cambios en la dirección de la tendencia y para generar señales de compra y venta. Cuando la línea MACD cruza por encima de la línea de señal, se considera una señal de compra, mientras que cuando la línea MACD cruza por debajo de la línea de señal, se considera una señal de venta.

MACD Signal es la media móvil exponencial de 9 días del MACD. Esto suaviza el MACD y genera una línea que se mueve más lentamente y que se utiliza para generar señales de compra o venta. Cuando la línea del MACD cruza por encima de la línea del MACD Signal, se considera una señal de compra, mientras que cuando cruza por debajo, se considera una señal de venta.

El MACD es el indicador principal que refleja la tendencia de los precios, mientras que el MACD Signal se utiliza para confirmar y filtrar las señales de compra o venta generadas por el MACD.

##Importacion de bibliotecas y libreias:
"""

import yfinance as yf
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from pandas._libs.lib import count_level_2d
import requests
from bs4 import BeautifulSoup
import yfinance as yf
from textblob import TextBlob
import pandas as pd
import time
from IPython.display import clear_output
import datetime
import pytz
import ta
from IPython.display import Image
"""# Obtener y tratar datos:

###1 - Obtener datos desde yahoo finance

### 2 - Nuevo df con columnas: DataTime(index) - Close - Volume

###3 - Eliminación de filas con volume=0

###4 - identificar índices duplicados y trátalos dejando sólo índices únicos

###5 - buscar valores nulos en la columna Close y trátalos:
"""

#función obtencion:
    # 1 - Obtener datos desde yahoo finance:
    # Obtener los datos del último año con intervalos de 5 minutos

def get_df_bitcoin():
    symbol = "BTC-USD"
    period = "7d"
    interval = "5m"
    df = yf.download(symbol, period=period, interval=interval)
    # Formatear la columna de fecha y hora:
    df.index = df.index.strftime("%Y-%m-%d %H:%M")
    #Valores de Precio de cierre enteros:
    df['Close'] = df['Close'].astype(int)

    # Guardar los datos en un dataframe
    df_bitcoin = pd.DataFrame(df)

    # Agregar columnas para el RSI y MACD
    df_bitcoin["rsi"] = (ta.momentum.RSIIndicator(df_bitcoin["Close"]).rsi()).round(0)
    df_bitcoin["macd"] = (ta.trend.MACD(df_bitcoin["Close"]).macd()).round(0)
    df_bitcoin["macd_signal"] = (ta.trend.MACD(df_bitcoin["Close"]).macd_signal()).round(0)

    return df_bitcoin

get_df_bitcoin()

#función reacondicionamiento de datos:

def get_df_bitcoin_limpio():

    df_data=get_df_bitcoin()

    # 2 - Crear df con columnas: DataTime - Close - Volume
    df_bitcoin_limpio= df_data[['Close','Volume','rsi','macd','macd_signal']]

    # 3 - Eliminar filas con volume=0
    df = df_bitcoin_limpio[df_bitcoin_limpio['Volume'] != 0]

    # 4 - Encontrar los índices duplicados
    duplicados = df.index.duplicated()

    # Eliminar las filas duplicadas
    df = df[~duplicados]

    # 5 - Elimina filas con Close=0
    df_bitcoin_limpio = df[df['Close'] != 0]

    return df_bitcoin_limpio

get_df_bitcoin_limpio()

# get_df_bitcoin_limpio().isna().sum()

# get_df_bitcoin_limpio().isnull().sum()

# def df_bitcoin():
#     df=get_df_bitcoin_limpio()

#     # Agregar columnas para el RSI y MACD
#     df["rsi"] = ta.momentum.RSIIndicator(df["Close"]).rsi()
#     df["macd"] = ta.trend.MACD(df["Close"]).macd()
#     return df

"""##Cálculos de valores estadísticos:"""

#Cálculos de valores estadísticos: df_bitcoin_limpio
def describir():
    df=get_df_bitcoin_limpio()
    media_bitcoin=int(df['Close'].mean())
    max=int(df['Close'].max())
    min=int(df['Close'].min())
    count=df['Close'].count()
    # print('Cantidad:',count, 'Media:',media_bitcoin,'Min:',min, 'Max:',max)
    return [media_bitcoin,max,min,count]

describir()

"""#identificar y eliminar los outliers

## utiliza un gráfico de boxplot:
"""

def boxplot_grafico():
    df=get_df_bitcoin_limpio()

    sns.set(style="whitegrid", rc={"figure.figsize":(12,6)})

    cuartiles = [0, 0.25, 0.5, 0.75, 1]

    valores = df['Close'].quantile(cuartiles)

    colores = ['#4c72b0', '#55a868', '#c44e52', '#8172b2']

    sns.boxplot(y='Close', data=df, orient='v', palette=colores, whis=2, width=0.25)

    plt.axhline(y=valores[0], linestyle='--', color='#FFC0CB')
    plt.axhline(y=valores[1], linestyle='--', color='#FFC0CB')
    plt.axhline(y=df['Close'].mean(), linestyle='--', color='#FFC0CB')

    plt.text(-0.2, valores[0], f'Mínimo: {valores[0]:.0f}', fontsize=10, ha='center', va='bottom', color='#4682B4')
    plt.text(-0.2, valores[0.25], f'Q1: {valores[0.25]:.0f}', fontsize=10, ha='center', va='top', color='#1f77b4')
    plt.text(-0.2, valores[0.75], f'Q3: {valores[0.75]:.0f}', fontsize=10, ha='center', va='bottom', color='#1f77b4')
    plt.text(-0.2, valores[1], f'Máximo: {valores[1]:.0f}', fontsize=10, ha='center', va='bottom', color='#4682B4')
    plt.text(-0.2, df['Close'].mean(), f'Media: {df["Close"].mean():.0f}', fontsize=10, ha='center', va='top', color='#1f77b4')

    mediana = np.median(df['Close'])
    plt.text(-0.2, mediana, f'Mediana: {mediana:.0f}', fontsize=10, ha='center', va='bottom', color='black')

    plt.ylim(valores[0]-0.1*(valores[1]-valores[0]), valores[1]+0.1*(valores[1]-valores[0]))

    plt.title('Distribución de precios de Bitcoin en dólares', fontsize=16)

    # Guardar la gráfica en el directorio raíz del proyecto
    plt.savefig('boxplot_bitcoin.png', bbox_inches='tight')

    #Retornar para mostrar grafica:
    # return plt.show()

"""##Grafico boxplot:"""

boxplot_grafico()

"""#Delimitando datos con query: entre Q1 y Q3"""

def between_quartiles():
    df=get_df_bitcoin_limpio()
    cuartiles = [0, 0.25, 0.5, 0.75, 1]
    valores = df['Close'].quantile(cuartiles)
    df_bitcoin_cuartiles = df.query('Close > ' + str(int(valores[0.25])) + ' & Close < ' + str(int(valores[0.75])))

    return df_bitcoin_cuartiles

between_quartiles()

"""##Nuevo BOXPLOT desde Q1 a Q3"""

def new_boxplot():
    df_new= between_quartiles()

    sns.set(style="whitegrid", rc={"figure.figsize":(12,6)})

    cuartiles = [0, 0.25, 0.5, 0.75, 1]

    valores = df_new['Close'].quantile(cuartiles)

    colores = ['#4c72b0', '#55a868', '#c44e52', '#8172b2']

    sns.boxplot(y='Close', data=df_new, orient='v', palette=colores, whis=2, width=0.25)

    plt.axhline(y=valores[0], linestyle='--', color='#FFC0CB')
    plt.axhline(y=valores[1], linestyle='--', color='#FFC0CB')
    plt.axhline(y=df_new['Close'].mean(), linestyle='--', color='#FFC0CB')

    plt.text(-0.2, valores[0], f'Mínimo: {valores[0]:.0f}', fontsize=10, ha='center', va='bottom', color='#4682B4')
    plt.text(-0.2, valores[0.25], f'Q1: {valores[0.25]:.0f}', fontsize=10, ha='center', va='top', color='#1f77b4')
    plt.text(-0.2, valores[0.75], f'Q3: {valores[0.75]:.0f}', fontsize=10, ha='center', va='bottom', color='#1f77b4')
    plt.text(-0.2, valores[1], f'Máximo: {valores[1]:.0f}', fontsize=10, ha='center', va='bottom', color='#4682B4')
    plt.text(-0.2, df_new['Close'].mean(), f'Media: {df_new["Close"].mean():.0f}', fontsize=10, ha='center', va='top', color='#1f77b4')

    mediana = np.median(df_new['Close'])
    plt.text(0, mediana, f'Mediana: {mediana:.0f}', fontsize=10, ha='center', va='bottom', color='black')

    plt.ylim(valores[0]-0.1*(valores[1]-valores[0]), valores[1]+0.1*(valores[1]-valores[0]))

    plt.title('Distribución de precios de Bitcoin en dólares', fontsize=16)

    # Guardar la gráfica en el directorio raíz del proyecto
    plt.savefig('boxplot_bitcoin_between_quartiles.png', bbox_inches='tight')

    #Retornar para mostrar grafica:
    # return plt.show()

new_boxplot()

"""###Guardar en drive el df_bitcoin"""

df_new= get_df_bitcoin()
df_new.to_csv('bitcoin.csv',sep=';',index='False')

"""#Extraer Tendencias:"""

def extraer_tendencias():
    global precio_actual, tendencia

    # Hacer la petición GET a la página web
    page = requests.get('https://coinmarketcap.com/')

    # Crear el objeto BeautifulSoup a partir del HTML de la página web
    soup = BeautifulSoup(page.content, 'html.parser')

    # Encontrar el precio actual del Bitcoin
    precio = soup.find('a', {'href': '/currencies/bitcoin/#markets'}).find('span').text.strip().replace('$', '').replace(',', '')
    # precio = soup.find('a', {'href': '/currencies/bitcoin/#markets/'}).find('span').text.strip().replace('$', '').replace(',', '')
    # Convertir el precio a un número en coma flotante
    precio_actual = float(precio)

    # Análisis de tendencia a partir del icono up o down
    span_element = soup.find('span', {'class': ['icon-Caret-up', 'icon-Caret-down']})
    if 'icon-Caret-up' in span_element['class']:
        tendencia = 'Alta'
    else:
        tendencia = 'Baja'

    # Encontrar la variación del precio 24hs
    porcentaje = soup.find('span', {'class': 'sc-d55c02b-0 iwhBxy'}).text.strip().replace('$', '').replace(',', '')
    # porcentaje = soup.find('span', {'class': 'sc-97d6d2ca-0 bQjSqS'}).text.strip().replace('$', '').replace(',', '')

    return [int(precio_actual), tendencia,porcentaje]

extraer_tendencias()

"""#Tomar decisiones"""

def tomar_decisiones():
    global symbol, period, interval, df_bitcoin, precio_actual, tendencia, media,rsi,macd,macdsignal,ma50,ma200

    df=between_quartiles()

    # Último RSI
    rsi=df['rsi'][-1]
    # Últimol MACD
    macd=df['macd'][-1]
    # Último MACD-SIGNAL
    macdsignal = df['macd_signal'][-1]

    # Calcular la media móvil de 50 días y 200 días
    df["ma50"] = df["Close"].rolling(50).mean()
    df["ma200"] = df["Close"].rolling(200).mean()

    ma50=df["ma50"].iloc[-1]
    ma200=df["ma200"].iloc[-1]

    #Precio actual
    precio = extraer_tendencias()[0]
    #Tendencia actual
    tendencia=extraer_tendencias()[1]
    #media
    media = df['Close'].mean()

    # Aplicar el criterio de decisión

    if precio > media and rsi > 50 and macd > macdsignal and precio > ma50 and precio > ma200:
        decision = "Comprar"
        explicacion ="Explicación: El precio actual está por encima de la media, el RSI es alto, el MACD está por encima de su señal,\n el precio actual está por encima de la MA50 y la MA200, lo que indica una tendencia alcista fuerte y una buena oportunidad para comprar."
    elif precio < media and rsi < 50 and macd < macdsignal and precio < ma50 and precio < ma200:
        decision = "Vender"
        explicacion ="Explicación: El precio actual está por debajo de la media, el RSI es bajo, el MACD está por debajo de su señal,\n el precio actual está por debajo de la MA50 y la MA200, lo que indica una tendencia bajista fuerte y una buena oportunidad para vender."
    else:
        decision = "Mantener"
        if tendencia == "Alta":
            if precio > media and precio > ma50 and precio > ma200:
                explicacion ="Explicación: El precio actual está por encima de la media, la MA50 y la MA200, lo que indica una tendencia alcista.\n Aunque el RSI y el MACD no son muy altos, se recomienda mantener ya que la tendencia general es positiva y puede haber potencial para ganancias adicionales."
            elif precio < media and precio < ma50 and precio < ma200:
                explicacion ="Explicación: El precio actual está por debajo de la media, la MA50 y la MA200, lo que indica una tendencia bajista.\n Aunque el RSI y el MACD no son muy bajos, se recomienda mantener ya que la tendencia general es negativa y puede haber potencial para disminución adicional en las pérdidas."
            else:
                explicacion ="Explicación: Aunque la tendencia general es alcista, el precio actual no está lo suficientemente por encima de la media,\n la MA50 y la MA200 para justificar una compra adicional. Sin embargo, tampoco hay señales fuertes de venta, por lo que se recomienda mantener y seguir observando."
        elif tendencia == "Baja":
            if precio < media and precio < ma50 and precio < ma200:
                explicacion ="Explicación: El precio actual está por debajo de la media, la MA50 y la MA200, lo que indica una tendencia bajista.\n Aunque el RSI y el MACD no son muy bajos, se recomienda mantener ya que la tendencia general es negativa y puede haber potencial para disminución adicional en las pérdidas."
            elif precio > media and precio > ma50 and precio > ma200:
                explicacion ="Explicación: El precio actual está por encima de la media, la MA50 y la MA200, lo que indica una tendencia alcista.\n Aunque el RSI y el MACD no son muy altos, se recomienda mantener ya que la tendencia general es positiva y puede haber potencial para disminución adicional en las pérdidas."

    return [decision,explicacion]

def print_algoritmo_decision():
    print('Decisión:', tomar_decisiones()[0]),print(tomar_decisiones()[1]),print('Tendencia:',tendencia),print('Media:',int(media)),print('Precio:',int(precio_actual)),print('RSI:',rsi),
    print('MACD:',macd),print('M-Signal:',macdsignal), print('ma50:',ma50), print('ma200:',ma200)
    return

tomar_decisiones()

print_algoritmo_decision()

"""#Gráfico de lineas para ver la tendencia"""


def graficar():

    df= get_df_bitcoin()
    # crear la figura y los ejes
    fig, ax = plt.subplots(figsize=(16,5))

    # trazar los datos en los ejes
    ax.plot(df.index, df["Close"])

    # trazar una línea que indique el valor medio
    mean_price = df["Close"].mean()
    ax.axhline(mean_price, color="red", linestyle="--")

    # personalizar la apariencia del gráfico
    ax.set_xlabel("Fecha")
    ax.set_ylabel("Precio")
    ax.set_title("Evolución del Bitcoin a lo largo del tiempo")

    # mostrar la decisión del algoritmo_decision
    decision = tomar_decisiones()[0]
    info = tomar_decisiones()[1]

    # Mostrar decision en grafico
    ax.text(0.8, 0.95, f"Decisión: {decision}", transform=ax.transAxes, fontsize=20, color='red',
            verticalalignment='top',horizontalalignment='center', bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.5))
    # ax.text(0.7, 0.8, f"Decisión: {info}", transform=ax.transAxes, fontsize=10, color='black',
    #         verticalalignment='top',horizontalalignment='center', bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.5))

    # Guardar la gráfica en el directorio raíz del proyecto
    plt.savefig('boxplot_bitcoin_decision.png', bbox_inches='tight')

    #Retornar para mostrar grafica:
    # return plt.show()

graficar()

def grafica_tendencias():
    #Data Frame
    data = get_df_bitcoin_limpio()

    #Calcular media:
    mean_price = data["Close"].mean()

    #Desicion:
    decision=tomar_decisiones()[0]

    # Calcular el RSI
    rsi = data['rsi'][-1]

    # Calcular el MACD
    macd = data['macd'][-1]

    # Calcular el MACD-SIGNAL
    macdsignal = data['macd_signal'][-1]

    # Calcular indicadores técnicos
    data["MA50"] = data["Close"].rolling(window=50).mean()
    data["MA200"] = data["Close"].rolling(window=200).mean()
    data["RSI"] = data['rsi']
    data["MACD"]= data['macd']
    data["M-Signal"] =data['macd_signal']

    # Graficar los precios con las medias móviles
    fig, ax = plt.subplots(figsize=(12,6))
    data["Close"].plot(ax=ax, color="black", label="Precio", linewidth=0.7)
    data["MA50"].plot(ax=ax, color="blue", label="Media Móvil de 50 días", linewidth=0.5)
    data["MA200"].plot(ax=ax, color="red", label="Media Móvil de 200 días", linewidth=0.5)
    ax.axhline(y=mean_price, color="green", linestyle="-",label='Precio Medio', linewidth=0.5)
    ax.legend(loc="best",fontsize=9)
    ax.set_xlabel("Fecha")
    ax.set_ylabel("Precio (USD)")
    ax.set_title("Bitcoin Precios con Medias Móviles")

    #Texto explicativo de la grafica:
    text_price_medias_01= "Interpretación: Esta gráfica muestra el precio histórico de Bitcoin en color gris, junto con las medias móviles"
    text_price_medias_02="de 50 y 200 días en azul y rojo, respectivamente. "
    text_price_medias_03= "La media móvil de 50 días se utiliza comúnmente como un indicador de tendencia a corto plazo, mientras que la media"
    text_price_medias_04="móvil de 200 días se utiliza como un indicador de tendencia a largo plazo."

    # Mostrar decision en grafico
    ax.text(0.5, 0.95, f"Decisión: {decision}", transform=ax.transAxes, fontsize=20, color='red', verticalalignment='top',horizontalalignment='center', bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.5))

    ax.text(0, -0.2,text_price_medias_01, transform=ax.transAxes, fontsize=10, ha="left")
    ax.text(0, -0.25,text_price_medias_02 , transform=ax.transAxes, fontsize=10, ha="left")
    ax.text(0, -0.3,text_price_medias_03, transform=ax.transAxes, fontsize=10, ha="left")
    ax.text(0, -0.35,text_price_medias_04 , transform=ax.transAxes, fontsize=10, ha="left")

    # Guardar la figura
    plt.savefig('tendencias_DECISION.png', bbox_inches='tight')

    # Graficar el RSI

    fig, ax = plt.subplots(figsize=(12,6))
    data["RSI"].plot(ax=ax, color="purple", label='Índice de Fuerza Relativa',linewidth=0.7)
    ax.axhline(y=70, color="green", linestyle="--",label='Nivel de Sobrecompra: 70',linewidth=0.9)
    ax.axhline(y=30, color="red", linestyle="--",label='Nivel de Sobreventa: 30',linewidth=0.9)
    ax.legend(loc="best",fontsize=9)
    ax.set_xlabel("Fecha")
    ax.set_ylabel("RSI")
    ax.set_title("RSI")

    #Texto explicativo de RSI:
    text_RSI_01= "Interpretación: Esta gráfica muestra el Indice de Fuerza Relativa (RSI) de Bitcoin en color morado. Los valores del RSI"
    text_RSI_02= "oscilan entre 0 y 100, y los niveles de sobrecompra y sobreventa se definen típicamente en 70 y 30, respectivamente."
    text_RSI_03= "Cuando el RSI se acerca a los 30, se considera que el precio de Bitcoin está sobrevendido y podría aumentar en el futuro."
    text_RSI_04= "Cuando el RSI se acerca a los 70, se considera que el precio de Bitcoin está sobrecomprado y podría disminuir en el futuro."

    ax.text(0, -0.20,text_RSI_01, transform=ax.transAxes, fontsize=10, ha="left")
    ax.text(0, -0.25,text_RSI_02 , transform=ax.transAxes, fontsize=10, ha="left")
    ax.text(0, -0.3,text_RSI_03, transform=ax.transAxes, fontsize=10, ha="left")
    ax.text(0, -0.35,text_RSI_04 , transform=ax.transAxes, fontsize=10, ha="left")

    # Guardar la figura 
    plt.savefig('tendencias_RSI.png', bbox_inches='tight')

    # Graficar el MACD y la MACD-Señal
    fig, ax = plt.subplots(figsize=(12,6))

    data["MACD"].plot(ax=ax, color="blue", label="MACD: Diferencia entre MA de 12 y 26 días",linewidth=0.7)
    data["M-Signal"].plot(ax=ax, color="red", label="M-Signal: : MA de 9 días del MACD",linewidth=0.7)
    ax.axhline(y=0, color="black", linestyle="--",linewidth=0.7)
    ax.legend(loc="best",fontsize=9)
    ax.set_xlabel("Fecha")
    ax.set_ylabel("MACD")
    ax.set_title("MACD y Señal")

    #Texto explicativo de MACD y la MACD-Señal:
    text_MACD_01= "El gráfico muestra el indicador MACD y su señal para el precio de Bitcoin. El MACD es un indicador que se utiliza para"
    text_MACD_02= "identificar cambios en la tendencia y la fuerza de los movimientos de los precios. Se calcula a partir de la diferencia"
    text_MACD_03= "entre dos promedios móviles exponenciales de diferentes periodos. La línea de señal es una media móvil exponencial del MACD."
    text_MACD_04= "Cuando la línea del MACD cruza por encima de la línea de señal, es una señal alcista, y cuando cruza por debajo, es una señal bajista."

    # Agregar cuadro de texto debajo del gráfico
    ax.text(0, -0.2,text_MACD_01, transform=ax.transAxes, fontsize=10, ha="left", color='black')
    ax.text(0, -0.25,text_MACD_02, transform=ax.transAxes, fontsize=10, ha="left", color='black')
    ax.text(0, -0.3,text_MACD_03, transform=ax.transAxes, fontsize=10, ha="left", color='black')
    ax.text(0, -0.35,text_MACD_04 , transform=ax.transAxes, fontsize=10, ha="left", color='black')

    # Guardar la figura 
    plt.savefig('tendencias_MACD.png', bbox_inches='tight')

    # Mostrar la figura con todas las gráficas
    # plt.show()
    # Mostrar la gráfica
    # return plt.show()

grafica_tendencias()




"""#Automatizar:"""

def automatizar():
      contador=0
      while True:
          contador+=1
          get_df_bitcoin()
          get_df_bitcoin_limpio()
          between_quartiles()
          extraer_tendencias()
          tomar_decisiones()

          tz = pytz.timezone('America/Argentina/Buenos_Aires')
          now = datetime.datetime.now(tz)
          print("Hora de verificación:", now.strftime("%H:%M:%S"))
          print("Ejecuciones: " ,contador," \n")
          print("-----------------------------------\n")
          print_algoritmo_decision()
          print("-----------------------------------\n")
          grafica_tendencias()
          clear_output(wait=True)

          time.sleep(10) #ciclo cada 300 segundos
        #   ruta_imagen = 'tendencias.png'
        #   Image(filename=ruta_imagen)
    #   return

automatizar()

